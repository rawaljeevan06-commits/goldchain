<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Withdrawal | GoldChain</title>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>

  <div class="topbar">Withdrawal ‚Äî Verified users only</div>

  <header class="header">
    <div class="container header-in">
      <a class="brand" href="index.html">
        <img src="images/logo.png" alt="GoldChain Logo">
        <span>GoldChain</span>
      </a>

      <nav class="nav">
        <a href="dashboard.html">Dashboard</a>
      </nav>

      <div class="actions">
        <button id="backBtn" class="btn btn-outline" type="button">Back</button>
        <button id="logoutBtn" class="btn btn-logout" type="button">Logout</button>
      </div>
    </div>
  </header>

  <section class="section">
    <div class="container">
      <div class="card">
        <h2>Request Withdrawal</h2>
        <p class="small" id="userEmail">Loading‚Ä¶</p>

        <div style="display:grid; gap:10px; margin-top:12px;">
          <div class="card" style="padding:12px;">
            <p class="muted">Status</p>
            <p class="big" id="statusText">Checking‚Ä¶</p>
          </div>

          <div class="card" style="padding:12px;">
            <p class="muted">Plan</p>
            <p class="big" id="planText">‚Äî</p>
            <p class="muted" id="profitText">‚Äî</p>
          </div>

          <div class="card" style="padding:12px;">
            <p class="muted">Available Balance</p>
            <p class="big" id="availableText">$0.00</p>
            <p class="muted" id="lockInfo">‚Äî</p>
          </div>
        </div>

        <hr style="margin:16px 0; opacity:.25;">

        <h3 style="margin-bottom:8px;">Submit request</h3>

        <div style="display:grid; gap:10px;">
          <input id="wallet" type="text" placeholder="Wallet Address (USDT/TRC20 or BTC or ETH)" />
          <input id="amount" type="number" placeholder="Amount (USD)" />
          <input id="note" type="text" placeholder="Note (optional)" />

          <button id="submitBtn" class="btn btn-primary" type="button">Submit Request</button>
          <p class="small" id="msg"></p>
        </div>

      </div>
    </div>
  </section>

  <script type="module">
    import { auth, db } from "./js/firebase.js?v=6";
    import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
    import {
      collection, query, where, limit, getDocs, orderBy,
      addDoc, serverTimestamp,
      doc, getDoc
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    const userEmailEl = document.getElementById("userEmail");
    const statusText  = document.getElementById("statusText");
    const planText    = document.getElementById("planText");
    const profitText  = document.getElementById("profitText");
    const availableEl = document.getElementById("availableText");
    const lockInfoEl  = document.getElementById("lockInfo");
    const msgEl       = document.getElementById("msg");

    const walletEl    = document.getElementById("wallet");
    const amountEl    = document.getElementById("amount");
    const noteEl      = document.getElementById("note");
    const submitBtn   = document.getElementById("submitBtn");

    document.getElementById("backBtn").onclick = () => window.location.href="dashboard.html";
    document.getElementById("logoutBtn").onclick = async () => {
      try { await signOut(auth); } catch(e) {}
      window.location.replace("login.html");
    };

    function money(n){ return `$${Number(n||0).toFixed(2)}`; }
    function setMsg(t){ msgEl.textContent = t || ""; }

    // ‚úÖ Monthly percent rules
    // 350/700/1000 => 16% monthly
    // 5000+        => 18% monthly
    function monthlyPercentByPlanAmount(planAmount){
      const a = Number(planAmount)||0;
      if (a >= 5000) return 18;
      if (a >= 350)  return 16;
      return 0;
    }

    // ‚úÖ Profit unlock days by plan amount
    // 5000+ => 15 days
    // 1000  => 15 days
    // 700   => 30 days
    // 350   => 45 days
    function profitUnlockDaysByPlanAmount(planAmount){
      const a = Number(planAmount)||0;
      if (a >= 5000) return 15;
      if (a >= 1000) return 15;
      if (a >= 700)  return 30;
      if (a >= 350)  return 45;
      return null;
    }

    // ‚úÖ Capital unlock for ALL plans after 30 days
    function capitalUnlockDays(){
      return 30;
    }

    function tsToDate(x){
      try{
        if(!x) return null;
        if(typeof x.toDate==="function") return x.toDate();
        return new Date(x);
      }catch{ return null; }
    }

    function fullDaysSince(fromDate, toDate){
      // counts full days passed (0,1,2,...)
      const ms = (toDate.getTime() - fromDate.getTime());
      return Math.max(0, Math.floor(ms / (1000*60*60*24)));
    }

    async function getUserProfile(uid){
      const snap = await getDoc(doc(db, "users", uid));
      if (!snap.exists()) return null;
      return snap.data();
    }

    async function getVerifiedPayments(user){
      const qv = query(
        collection(db, "payments"),
        where("uid", "==", user.uid),
        where("status", "==", "verified"),
        orderBy("createdAt", "desc"),
        limit(50)
      );
      const snap = await getDocs(qv);
      const out = [];
      snap.forEach(d => out.push({ id: d.id, ...d.data() }));
      return out;
    }

    async function hasPendingWithdrawal(user){
      const qp = query(
        collection(db, "withdrawals"),
        where("uid", "==", user.uid),
        where("status", "==", "pending"),
        limit(1)
      );
      const snap = await getDocs(qp);
      return !snap.empty;
    }

    async function getUserWithdrawals(user){
      const qx = query(
        collection(db, "withdrawals"),
        where("uid", "==", user.uid),
        limit(300)
      );
      const snap = await getDocs(qx);
      const out = [];
      snap.forEach(d => out.push({ id: d.id, ...d.data() }));
      return out;
    }

    // ‚úÖ DAILY PROFIT ACCRUAL:
    // dailyProfit = (planAmount * monthlyPercent/100) / 30
    // accruedProfit = dailyProfit * daysPassed
    // withdrawableProfit = (if profit unlocked) accruedProfit - alreadyWithdrawnProfit
    function computeWithdrawableByPayment(payments, withdrawals){
      const now = new Date();

      // already withdrawn per paymentId + type
      const withdrawnMap = {}; // { [paymentId]: {profit: n, capital: n} }

      for (const w of (withdrawals || [])){
        const pid = w.paymentId || w.sourcePaymentId || null;
        if (!pid) continue;

        const type = (w.withdrawType || "").toLowerCase();
        const amt = Number(w.amount || 0);

        if (!withdrawnMap[pid]) withdrawnMap[pid] = { profit: 0, capital: 0 };

        if (type === "profit") withdrawnMap[pid].profit += amt;
        else if (type === "capital") withdrawnMap[pid].capital += amt;
        // old withdrawal docs without type are ignored (safe)
      }

      const computed = [];

      for (const p of (payments || [])){
        const planAmt = Number(p.amount ?? p.planAmount ?? 0);
        if (!planAmt || planAmt <= 0) continue;

        const verifiedDate =
          tsToDate(p.verifiedAt || p.createdAt || p.createdAtISO) || null;
        if (!verifiedDate) continue;

        const pctMonthly = monthlyPercentByPlanAmount(planAmt);
        const profitUnlockDays = profitUnlockDaysByPlanAmount(planAmt);
        const capitalUnlock = capitalUnlockDays();

        const daysPassed = fullDaysSince(verifiedDate, now);

        const dailyProfit = ((planAmt * (pctMonthly/100)) / 30);
        const accruedProfit = dailyProfit * daysPassed; // keeps growing daily

        const profitUnlocked = (profitUnlockDays != null) && (daysPassed >= profitUnlockDays);
        const capitalUnlocked = (daysPassed >= capitalUnlock);

        const alreadyProfit = withdrawnMap[p.id]?.profit || 0;
        const alreadyCapital = withdrawnMap[p.id]?.capital || 0;

        const remainingProfit = profitUnlocked
          ? Math.max(0, accruedProfit - alreadyProfit)
          : 0;

        const remainingCapital = capitalUnlocked
          ? Math.max(0, planAmt - alreadyCapital)
          : 0;

        const profitRemainingDays = (profitUnlockDays == null)
          ? null
          : Math.max(0, profitUnlockDays - daysPassed);

        const capitalRemainingDays = Math.max(0, capitalUnlock - daysPassed);

        computed.push({
          raw: p,
          paymentId: p.id,
          planAmt,
          pctMonthly,
          verifiedDate,
          daysPassed,

          dailyProfit,
          accruedProfit,

          profitUnlocked,
          capitalUnlocked,

          remainingProfit,
          remainingCapital,

          profitRemainingDays,
          capitalRemainingDays
        });
      }

      return computed;
    }

    function pickDisplayPlan(computed){
      if (!computed || computed.length === 0) return null;
      const copy = [...computed];
      copy.sort((a,b) => b.planAmt - a.planAmt);
      return copy[0];
    }

    function summarizeLocks(computed){
      if (!computed || computed.length === 0) return "You must have a verified deposit to withdraw.";

      const totalProfitAvail = computed.reduce((s,x) => s + (x.remainingProfit || 0), 0);
      const totalCapitalAvail = computed.reduce((s,x) => s + (x.remainingCapital || 0), 0);

      if (totalProfitAvail > 0 || totalCapitalAvail > 0){
        const parts = [];
        if (totalProfitAvail > 0) parts.push(`Profit available: ${money(totalProfitAvail)}`);
        if (totalCapitalAvail > 0) parts.push(`Capital available: ${money(totalCapitalAvail)}`);
        return parts.join(" ‚Ä¢ ");
      }

      // nearest unlock info
      let minProfit = null;
      let minCapital = null;

      for (const x of computed){
        if (!x.profitUnlocked && x.profitRemainingDays != null){
          minProfit = (minProfit == null) ? x.profitRemainingDays : Math.min(minProfit, x.profitRemainingDays);
        }
        if (!x.capitalUnlocked){
          minCapital = (minCapital == null) ? x.capitalRemainingDays : Math.min(minCapital, x.capitalRemainingDays);
        }
      }

      const lines = [];
      if (minProfit != null) lines.push(`üîí Profit unlock in ${minProfit} day(s).`);
      if (minCapital != null) lines.push(`üîí Capital unlock in ${minCapital} day(s) (30-day rule).`);
      return lines.join(" ");
    }

    // Allocate withdrawal amount:
    // 1) profit first (unlocked + remaining)
    // 2) then capital (unlocked + remaining)
    function allocateWithdrawal(computed, amount){
      let remaining = Number(amount || 0);
      const allocations = [];

      const profitList = [...computed].filter(x => (x.remainingProfit || 0) > 0);
      profitList.sort((a,b) => b.planAmt - a.planAmt);

      for (const x of profitList){
        if (remaining <= 0) break;
        const take = Math.min(remaining, x.remainingProfit);
        if (take > 0){
          allocations.push({
            paymentId: x.paymentId,
            withdrawType: "profit",
            amount: take,
            sourcePlanAmount: x.planAmt,
            monthlyPercent: x.pctMonthly,
            planName: x.raw.planName || ""
          });
          remaining -= take;
        }
      }

      const capList = [...computed].filter(x => (x.remainingCapital || 0) > 0);
      capList.sort((a,b) => b.planAmt - a.planAmt);

      for (const x of capList){
        if (remaining <= 0) break;
        const take = Math.min(remaining, x.remainingCapital);
        if (take > 0){
          allocations.push({
            paymentId: x.paymentId,
            withdrawType: "capital",
            amount: take,
            sourcePlanAmount: x.planAmt,
            monthlyPercent: x.pctMonthly,
            planName: x.raw.planName || ""
          });
          remaining -= take;
        }
      }

      return { allocations, remaining };
    }

    let STATE = {
      user: null,
      profile: null,
      payments: [],
      withdrawals: [],
      computed: [],
      pending: false,
      available: 0
    };

    function renderUI(){
      const computed = STATE.computed;

      if (!computed || computed.length === 0){
        statusText.textContent = "‚õî Not verified";
        planText.textContent = "‚Äî";
        profitText.textContent = "‚Äî";
        availableEl.textContent = "$0.00";
        lockInfoEl.textContent = "You must have a verified deposit to withdraw.";
        submitBtn.disabled = true;
        return;
      }

      const totalProfitAvail = computed.reduce((s,x) => s + (x.remainingProfit || 0), 0);
      const totalCapitalAvail = computed.reduce((s,x) => s + (x.remainingCapital || 0), 0);

      // Total allowed by rules
      const byRules = Math.max(0, totalProfitAvail + totalCapitalAvail);

      // Safety cap by users.balance
      const userBal = Number(STATE.profile?.balance || 0);
      STATE.available = Math.min(userBal, byRules);

      statusText.textContent = "‚úÖ Verified ‚Äî You can request withdrawal";

      const displayPlan = pickDisplayPlan(computed);
      if (displayPlan){
        planText.textContent =
          `${displayPlan.raw.planName || "Selected Plan"} ($${displayPlan.planAmt} ‚Ä¢ ${displayPlan.pctMonthly}% monthly)`;

        const pUnlock = displayPlan.profitUnlocked
          ? "‚úÖ Profit unlocked"
          : `üîí Profit unlock in ${displayPlan.profitRemainingDays} day(s)`;

        const cUnlock = displayPlan.capitalUnlocked
          ? "‚úÖ Capital unlocked"
          : `üîí Capital unlock in ${displayPlan.capitalRemainingDays} day(s)`;

        profitText.textContent =
          `Daily profit: $${displayPlan.dailyProfit.toFixed(2)} ‚Ä¢ Accrued: $${displayPlan.accruedProfit.toFixed(2)} ‚Ä¢ ${pUnlock} ‚Ä¢ ${cUnlock}`;
      } else {
        planText.textContent = "‚Äî";
        profitText.textContent = "‚Äî";
      }

      availableEl.textContent = money(STATE.available);

      if (STATE.pending){
        lockInfoEl.textContent = "‚è≥ You already have a pending withdrawal request.";
        submitBtn.disabled = true;
        return;
      }

      lockInfoEl.textContent = summarizeLocks(computed);

      submitBtn.disabled = (STATE.available <= 0);
    }

    async function loadState(){
      setMsg("");
      const user = STATE.user;

      const profile = await getUserProfile(user.uid);
      STATE.profile = profile;

      STATE.pending = await hasPendingWithdrawal(user);

      STATE.payments = await getVerifiedPayments(user);
      STATE.withdrawals = await getUserWithdrawals(user);

      STATE.computed = computeWithdrawableByPayment(STATE.payments, STATE.withdrawals);

      renderUI();
    }

    submitBtn.addEventListener("click", async () => {
      setMsg("");

      const wallet = String(walletEl.value||"").trim();
      const amount = Number(amountEl.value||0);
      const note   = String(noteEl.value||"").trim();

      if(!wallet || wallet.length < 8){
        setMsg("‚ùå Please enter a valid wallet address.");
        return;
      }

      if(!amount || amount <= 0){
        setMsg("‚ùå Enter a valid amount.");
        return;
      }

      if(STATE.pending){
        setMsg("‚ùå You already have a pending withdrawal request.");
        return;
      }

      if(amount > STATE.available){
        setMsg(`‚ùå Amount exceeds available (${money(STATE.available)}).`);
        return;
      }

      const { allocations, remaining } = allocateWithdrawal(STATE.computed, amount);

      if (!allocations.length || remaining > 0){
        setMsg("‚ùå Not enough unlocked profit/capital based on plan rules.");
        return;
      }

      submitBtn.disabled = true;
      setMsg("Submitting‚Ä¶");

      try{
        for (const a of allocations){
          await addDoc(collection(db, "withdrawals"), {
            uid: STATE.user.uid,
            email: STATE.user.email || "",
            wallet,
            amount: Number(a.amount),

            // New safe fields
            paymentId: a.paymentId,
            withdrawType: a.withdrawType,       // "profit" | "capital"
            planName: a.planName || "",
            sourcePlanAmount: Number(a.sourcePlanAmount || 0),
            monthlyPercent: Number(a.monthlyPercent || 0),

            note,
            status: "pending",
            createdAt: serverTimestamp()
          });
        }

        setMsg("‚úÖ Withdrawal request submitted (pending).");
        await loadState();
      }catch(e){
        console.error(e);
        setMsg("‚ùå Failed to submit withdrawal (check Firestore rules).");
      }finally{
        submitBtn.disabled = false;
      }
    });

    onAuthStateChanged(auth, async (user) => {
      if(!user){
        window.location.replace("login.html");
        return;
      }
      STATE.user = user;
      userEmailEl.textContent = user.email || "";
      await loadState();
    });
  </script>

</body>
</html>