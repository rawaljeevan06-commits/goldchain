// public/js/dashboard.js
import { auth, db } from "./firebase.js";

import {
  onAuthStateChanged,
  signOut
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

import {
  doc,
  getDoc,
  collection,
  query,
  where,
  orderBy,
  limit,
  getDocs
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

// ---------- helpers ----------
const $ = (id) => document.getElementById(id);

function setText(id, txt) {
  const el = $(id);
  if (el) el.textContent = txt;
}

function setValue(id, val) {
  const el = $(id);
  if (el) el.value = val;
}

function money(n) {
  const x = Number(n || 0);
  return x.toFixed(2);
}

function safeDate(v) {
  // supports Firestore Timestamp, ms, ISO string
  try {
    if (!v) return "—";
    if (typeof v === "object" && typeof v.toDate === "function") return v.toDate().toLocaleString();
    const d = new Date(v);
    return isNaN(d.getTime()) ? "—" : d.toLocaleString();
  } catch {
    return "—";
  }
}

// ---------- logout ----------
const logoutBtn = $("logoutBtn");
if (logoutBtn) {
  logoutBtn.addEventListener("click", async () => {
    try {
      await signOut(auth);
    } catch (e) {
      console.error("Logout error:", e);
    }
    window.location.replace("login.html");
  });
}

// ---------- withdraw button ----------
const withdrawBtn = $("withdrawBtn");
if (withdrawBtn) {
  withdrawBtn.addEventListener("click", () => {
    window.location.href = "withdrawal.html";
  });
}

// ---------- copy referral ----------
const copyRefBtn = $("copyRefBtn");
if (copyRefBtn) {
  copyRefBtn.addEventListener("click", async () => {
    const codeEl = $("myRefCode");
    if (!codeEl) return;
    try {
      await navigator.clipboard.writeText(codeEl.value || "");
      copyRefBtn.textContent = "Copied ✅";
      setTimeout(() => (copyRefBtn.textContent = "Copy"), 1200);
    } catch (e) {
      console.error("Copy failed:", e);
      alert("Copy failed. Please copy manually.");
    }
  });
}

// ---------- counters ----------
document.querySelectorAll(".counter").forEach((counter) => {
  const target = Number(counter.getAttribute("data-target") || 0);
  let current = 0;
  const step = Math.max(1, Math.floor(target / 80));

  const tick = () => {
    current += step;
    if (current >= target) {
      counter.textContent = String(target);
      return;
    }
    counter.textContent = String(current);
    requestAnimationFrame(tick);
  };

  tick();
});

// ---------- main ----------
onAuthStateChanged(auth, async (user) => {
  if (!user) {
    window.location.replace("login.html");
    return;
  }

  setText("emailEl", user.email || "—");

  // USER DOC
  try {
    const userRef = doc(db, "users", user.uid);
    const snap = await getDoc(userRef);

    if (snap.exists()) {
      const u = snap.data();

      setText("balanceEl", money(u.balance));
      setText("createdEl", safeDate(u.createdAt));
      setText("planEl", u.planName || (u.planAmount ? `$${u.planAmount}` : "No active plan"));
      setText("rateEl", u.planRate ? `${u.planRate}% return` : "");

      // referral code
      setValue("myRefCode", u.refCode || user.uid.slice(0, 8));
      setText("refEarn", money(u.refEarnings));

      // VIP
      const vip = Boolean(u.isVip || (u.planAmount && Number(u.planAmount) >= 5000));
      const vipEl = $("vipStatusEl");
      const vipBadge = $("vipBadge");
      if (vipEl) vipEl.textContent = vip ? "VIP Active ✅" : "Normal";
      if (vipBadge) vipBadge.style.display = vip ? "inline-block" : "none";
    } else {
      setText("planEl", "No user profile found");
    }
  } catch (e) {
    console.error("User load error:", e);
    setText("planEl", "Error loading user");
  }

  // TODAY TOTALS (simple)
  // NOTE: This uses client time. If you store a 'verifiedAt' timestamp, it works well enough.
  const startOfDay = new Date();
  startOfDay.setHours(0, 0, 0, 0);
  const startMs = startOfDay.getTime();

  // TOTAL VERIFIED DEPOSITS (real-time-like via fetch)
  try {
    const q1 = query(
      collection(db, "payments"),
      where("status", "==", "verified")
    );
    const snap = await getDocs(q1);

    let totalAll = 0;
    let totalToday = 0;

    snap.forEach((d) => {
      const p = d.data();
      const amt = Number(p.amount || 0);
      totalAll += amt;

      const t = p.verifiedAt || p.createdAt || p.timestamp;
      const ms =
        (t && typeof t === "object" && typeof t.toMillis === "function") ? t.toMillis()
        : (t && typeof t === "object" && typeof t.toDate === "function") ? t.toDate().getTime()
        : new Date(t).getTime();

      if (!isNaN(ms) && ms >= startMs) totalToday += amt;
    });

    setText("totalDepositsEl", money(totalAll));
    setText("todayDepositsEl", money(totalToday));
    const ticker = $("liveTicker");
    if (ticker) ticker.textContent = `Total verified deposits: $${money(totalAll)} (Today: $${money(totalToday)})`;
  } catch (e) {
    console.error("Deposit totals error:", e);
    setText("totalDepositsEl", "0.00");
    setText("todayDepositsEl", "0.00");
  }

  // TODAY APPROVED WITHDRAWALS
  try {
    const q2 = query(
      collection(db, "withdrawals"),
      where("status", "==", "approved")
    );
    const snap2 = await getDocs(q2);

    let totalTodayW = 0;

    snap2.forEach((d) => {
      const w = d.data();
      const amt = Number(w.amount || 0);

      const t = w.approvedAt || w.createdAt || w.timestamp;
      const ms =
        (t && typeof t === "object" && typeof t.toMillis === "function") ? t.toMillis()
        : (t && typeof t === "object" && typeof t.toDate === "function") ? t.toDate().getTime()
        : new Date(t).getTime();

      if (!isNaN(ms) && ms >= startMs) totalTodayW += amt;
    });

    setText("todayWithdrawalsEl", money(totalTodayW));
  } catch (e) {
    console.error("Withdraw totals error:", e);
    setText("todayWithdrawalsEl", "0.00");
  }
});