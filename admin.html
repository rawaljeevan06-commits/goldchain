<script type="module">
  import { auth, db } from "./js/firebase.js";
  import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    collection, query, where, orderBy, limit, getDocs, getDoc,
    doc, serverTimestamp,
    runTransaction, increment
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const adminInfo = document.getElementById("adminInfo");
  const adminBadge = document.getElementById("adminBadge");
  const paymentsBody = document.getElementById("paymentsBody");
  const withdrawalsBody = document.getElementById("withdrawalsBody");

  const msg = document.getElementById("msg");
  const wMsg = document.getElementById("wMsg");

  const refreshBtn = document.getElementById("refreshBtn");
  const logoutBtn = document.getElementById("logoutBtn");

  const tVerified = document.getElementById("tVerified");
  const tApprovedWd = document.getElementById("tApprovedWd");
  const tMoney = document.getElementById("tMoney");

  function esc(s) {
    return String(s ?? "").replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }

  function formatTime(ts) {
    try {
      if (!ts) return "-";
      if (typeof ts.toDate === "function") return ts.toDate().toLocaleString();
      return new Date(ts).toLocaleString();
    } catch { return "-"; }
  }

  function money(n){ return `$${Number(n||0).toFixed(2)}`; }

  function errText(e){
    const code = e?.code ? `(${e.code}) ` : "";
    const m = e?.message || String(e || "");
    return code + m;
  }

  async function loadTotals(){
    try{
      const pSnap = await getDocs(query(collection(db,"payments"), limit(500)));
      let verifiedCount = 0;
      let depositSum = 0;

      pSnap.forEach(d=>{
        const p = d.data();
        if(String(p.status||"").toLowerCase()==="verified"){
          verifiedCount++;
          depositSum += Number(p.amount||0);
        }
      });

      const wSnap = await getDocs(query(collection(db,"withdrawals"), limit(500)));
      let approvedCount = 0;
      let withdrawSum = 0;

      wSnap.forEach(d=>{
        const w = d.data();
        if(String(w.status||"").toLowerCase()==="approved"){
          approvedCount++;
          withdrawSum += Number(w.amount||0);
        }
      });

      if(tVerified) tVerified.textContent = String(verifiedCount);
      if(tApprovedWd) tApprovedWd.textContent = String(approvedCount);
      if(tMoney) tMoney.textContent = `${money(depositSum)} / ${money(withdrawSum)}`;
    }catch(e){
      console.warn("Totals failed:", e);
    }
  }

  async function loadPendingPayments() {
    if (!paymentsBody) return;
    paymentsBody.innerHTML = "";
    if (msg) msg.textContent = "Loading pending payments…";

    try {
      const q1 = query(
        collection(db, "payments"),
        where("status", "==", "pending"),
        orderBy("createdAt", "desc"),
        limit(50)
      );

      let snap;
      try { snap = await getDocs(q1); }
      catch {
        snap = await getDocs(query(
          collection(db, "payments"),
          where("status", "==", "pending"),
          limit(50)
        ));
      }

      if (snap.empty) { if (msg) msg.textContent = "✅ No pending payments."; return; }
      if (msg) msg.textContent = `Found ${snap.size} pending payment(s).`;

      snap.forEach((docSnap) => {
        const p  = docSnap.data();
        const id = docSnap.id;

        const tr = document.createElement("tr");
        tr.style.borderBottom = "1px solid rgba(255,255,255,.08)";

        tr.innerHTML = `
          <td style="padding:10px;">${esc(formatTime(p.createdAt))}</td>
          <td style="padding:10px;">${esc(p.email || p.uid || "-")}</td>
          <td style="padding:10px;">${esc(p.planName || p.plan || "-")}</td>
          <td style="padding:10px;">$${esc(p.amount ?? "-")}</td>
          <td style="padding:10px;">${esc(p.method || "-")}</td>
          <td style="padding:10px; max-width:260px; word-break:break-all;">${esc(p.txid || "-")}</td>
          <td style="padding:10px;">${esc(p.status || "-")}</td>
          <td style="padding:10px; display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn btn-primary" type="button" data-type="pay" data-act="approve" data-id="${esc(id)}">Approve</button>
            <button class="btn btn-outline" type="button" data-type="pay" data-act="reject" data-id="${esc(id)}">Reject</button>
          </td>
        `;
        paymentsBody.appendChild(tr);
      });

    } catch (e) {
      console.error(e);
      if (msg) msg.textContent = "❌ Failed to load payments: " + errText(e);
    }
  }

  async function loadPendingWithdrawals() {
    if (!withdrawalsBody) return;
    withdrawalsBody.innerHTML = "";
    if (wMsg) wMsg.textContent = "Loading pending withdrawals…";

    try {
      const q1 = query(
        collection(db, "withdrawals"),
        where("status", "==", "pending"),
        orderBy("createdAt", "desc"),
        limit(50)
      );

      let snap;
      try { snap = await getDocs(q1); }
      catch {
        snap = await getDocs(query(
          collection(db, "withdrawals"),
          where("status", "==", "pending"),
          limit(50)
        ));
      }

      if (snap.empty) { if (wMsg) wMsg.textContent = "✅ No pending withdrawals."; return; }
      if (wMsg) wMsg.textContent = `Found ${snap.size} pending withdrawal(s).`;

      snap.forEach((docSnap) => {
        const w  = docSnap.data();
        const id = docSnap.id;

        const tr = document.createElement("tr");
        tr.style.borderBottom = "1px solid rgba(255,255,255,.08)";

        tr.innerHTML = `
          <td style="padding:10px;">${esc(formatTime(w.createdAt))}</td>
          <td style="padding:10px;">${esc(w.email || w.uid || "-")}</td>
          <td style="padding:10px;">$${esc(w.amount ?? "-")}</td>
          <td style="padding:10px; max-width:320px; word-break:break-all;">${esc(w.wallet || w.walletAddress || "-")}</td>
          <td style="padding:10px;">${esc(w.status || "-")}</td>
          <td style="padding:10px; display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn btn-primary" type="button" data-type="wd" data-act="approve" data-id="${esc(id)}">Approve</button>
            <button class="btn btn-outline" type="button" data-type="wd" data-act="reject" data-id="${esc(id)}">Reject</button>
          </td>
        `;
        withdrawalsBody.appendChild(tr);
      });

    } catch (e) {
      console.error(e);
      if (wMsg) wMsg.textContent = "❌ Failed to load withdrawals: " + errText(e);
    }
  }

  // ✅ Approve / Reject payment
  async function setPaymentStatus(paymentId, status) {
    const payRef = doc(db, "payments", paymentId);

    await runTransaction(db, async (tx) => {
      const paySnap = await tx.get(payRef);
      if (!paySnap.exists()) return;

      const p = paySnap.data();
      const uid = p.uid;
      const email = p.email || "";
      const amount = Number(p.amount || 0);
      const planName = p.planName || p.plan || "";

      tx.update(payRef, { status, verifiedAt: serverTimestamp() });

      if (status !== "verified") return;
      if (!uid || !Number.isFinite(amount) || amount <= 0) return;

      const userRef = doc(db, "users", uid);

      tx.set(userRef, {
        email,
        paymentVerified: true,
        selectedPlan: planName,
        selectedPlanAt: serverTimestamp(),
        balance: increment(amount),
        referralEarnings: increment(0)
      }, { merge: true });

      tx.set(doc(collection(db, "audit")), {
        type: "payment_verified",
        paymentId,
        uid,
        email,
        amount,
        planName,
        byAdmin: auth.currentUser?.uid || "",
        at: serverTimestamp()
      });
    });
  }

  // ✅ Approve / Reject withdrawal
  async function setWithdrawalStatus(withdrawalId, status) {
    const wRef = doc(db, "withdrawals", withdrawalId);

    await runTransaction(db, async (tx) => {
      const wSnap = await tx.get(wRef);
      if (!wSnap.exists()) return;

      const w = wSnap.data();
      const uid = w.uid;
      const amount = Number(w.amount || 0);

      const upd = { status };
      if (status === "approved") upd.processedAt = serverTimestamp();
      tx.update(wRef, upd);

      if (status !== "approved") return;
      if (!uid || !Number.isFinite(amount) || amount <= 0) return;

      const userRef = doc(db, "users", uid);
      tx.set(userRef, { balance: increment(-amount) }, { merge: true });

      tx.set(doc(collection(db, "audit")), {
        type: "withdrawal_approved",
        withdrawalId,
        uid,
        amount,
        byAdmin: auth.currentUser?.uid || "",
        at: serverTimestamp()
      });
    });
  }

  // Buttons handler
  document.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-type][data-act][data-id]");
    if (!btn) return;

    const type = btn.getAttribute("data-type");
    const act  = btn.getAttribute("data-act");
    const id   = btn.getAttribute("data-id");
    if (!id) return;

    btn.disabled = true;

    try {
      if (type === "pay") {
        if (msg) msg.textContent = "Updating payment…";
        if (act === "approve") await setPaymentStatus(id, "verified");
        if (act === "reject")  await setPaymentStatus(id, "rejected");
        if (msg) msg.textContent = "✅ Payment updated.";
        await loadPendingPayments();
      }

      if (type === "wd") {
        if (wMsg) wMsg.textContent = "Updating withdrawal…";
        if (act === "approve") await setWithdrawalStatus(id, "approved");
        if (act === "reject")  await setWithdrawalStatus(id, "rejected");
        if (wMsg) wMsg.textContent = "✅ Withdrawal updated.";
        await loadPendingWithdrawals();
      }

      await loadTotals();

    } catch (err) {
      console.error(err);
      if (type === "pay" && msg) msg.textContent = "❌ Payment update failed: " + errText(err);
      if (type === "wd" && wMsg) wMsg.textContent = "❌ Withdrawal update failed: " + errText(err);
    } finally {
      btn.disabled = false;
    }
  });

  refreshBtn?.addEventListener("click", async () => {
    await loadPendingPayments();
    await loadPendingWithdrawals();
    await loadTotals();
  });

  logoutBtn?.addEventListener("click", async () => {
    try { await signOut(auth); } catch {}
    window.location.replace("login.html");
  });

  // ✅ SINGLE auth listener + Firestore admin check
  onAuthStateChanged(auth, async (user) => {
    if (!user) { window.location.replace("login.html"); return; }

    try {
      const roleSnap = await getDoc(doc(db, "users", user.uid));
      const roleData = roleSnap.exists() ? roleSnap.data() : {};

      if (roleData.admin !== true) {
        if (adminInfo) adminInfo.textContent = "❌ Access denied (not admin).";
        if (adminBadge) adminBadge.textContent = "❌ Not admin";
        window.location.replace("dashboard.html");
        return;
      }

      if (adminInfo) adminInfo.textContent = `✅ Admin: ${user.email || "-"} | UID: ${user.uid}`;
      if (adminBadge) adminBadge.textContent = "✅ Admin: " + (user.email || user.uid);

      await loadPendingPayments();
      await loadPendingWithdrawals();
      await loadTotals();

    } catch (e) {
      console.error(e);
      if (adminInfo) adminInfo.textContent = "❌ Error checking admin role.";
      if (adminBadge) adminBadge.textContent = "❌ Error";
      window.location.replace("dashboard.html");
    }
  });
</script>
